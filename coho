#!/usr/bin/env node
/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/

var fs = require('fs');
var optimist = require('optimist');
var path = require('path');
var shjs = require('shelljs');

var origWorkingDir = process.cwd();

var COMMON_RAT_EXCLUDES = [
    '*.wav',
    '*.webloc',
    '*jasmine-1.2.0*',
    '*.xcodeproj',
    '.*',
    '*-Info.plist',
    'VERSION',
    'node_modules',
    'thirdparty',
    'package.json',
    ];

var platformRepos = [
    {
        title: 'Android',
        id: 'android',
        repoName: 'cordova-android',
        cordovaJsPaths: ['framework/assets/www/cordova.js'],
        ratExcludes: [
            '*.properties',
            'bin',
            'gen',
            'proguard-project.txt'
        ]
    }, {
        title: 'iOS',
        id: 'ios',
        repoName: 'cordova-ios',
        cordovaJsPaths: ['CordovaLib/cordova.js'],
        versionFilePaths: [path.join('CordovaLib', 'VERSION')]
    }, {
        title: 'BlackBerry',
        id: 'blackberry',
        repoName: 'cordova-blackberry',
        cordovaJsPaths: [
            path.join('bbos', 'javascript', 'cordova.blackberry.js'),
            path.join('playbook', 'javascript', 'cordova.blackberry.js'),
            // bb10 JS path uses a different src, so logic is hardcoded below.
            ],
        versionFilePaths: [
            path.join('bbos', 'VERSION'),
            path.join('bbos', 'bin', 'templates', 'project', 'www', 'VERSION'),
            path.join('blackberry10', 'VERSION'),
            path.join('blackberry10', 'bin', 'templates', 'project', 'www', 'VERSION'),
            path.join('playbook', 'VERSION'),
            path.join('playbook', 'bin', 'templates', 'project', 'www', 'VERSION'),
            ]
    }, {
        title: 'Windows',
        id: 'windows',
        repoName: 'cordova-windows',
        cordovaJsSrcName: 'cordova.windows8.js',
        cordovaJsPaths: ['windows8/cordova.js', 'windows8/template/www/cordova.js'],
        versionFilePaths: [path.join('windows8', 'VERSION'), path.join('windows8', 'template', 'VERSION')]
    }, {
        title: 'Windows Phone 7',
        id: 'wp7',
        repoName: 'cordova-wp7',
        cordovaJsSrcName: 'cordova.windowsphone.js',
        cordovaJsPaths: ['templates/standalone/www/cordova.js']
    }, {
        title: 'Windows Phone 8',
        id: 'wp8',
        repoName: 'cordova-wp8',
        cordovaJsSrcName: 'cordova.windowsphone.js',
        cordovaJsPaths: ['common/www/cordova.js']
    }, {
        title: 'Mac OSX',
        id: 'osx',
        repoName: 'cordova-osx',
        cordovaJsPaths: ['CordovaFramework/cordova.js']
    }, {
        title: 'Bada',
        id: 'bada',
        repoName: 'cordova-bada',
        inactive: true
    }, {
        title: 'Bada WAC',
        id: 'bada-wac',
        repoName: 'cordova-bada-wac',
        inactive: true
    }, {
        title: 'WebOS',
        id: 'webos',
        repoName: 'cordova-webos',
        inactive: true
    }, {
        title: 'QT',
        id: 'qt',
        repoName: 'cordova-qt',
        inactive: true
    }, {
        title: 'Tizen',
        id: 'tizen',
        repoName: 'cordova-tizen',
        inactive: true
    }
];

var nonPlatformRepos = [
    {
        title: 'Docs',
        id: 'docs',
        repoName: 'cordova-docs'
    }, {
        title: 'MobileSpec',
        id: 'mobile-spec',
        repoName: 'cordova-mobile-spec',
        ratExcludes: [
          'jasmine.*',
          'html',
          'uubench.js',
        ]
    }, {
        title: 'Cordova JS',
        id: 'js',
        repoName: 'cordova-js'
    }, {
        title: 'Hello World App',
        id: 'app-hello-world',
        repoName: 'cordova-app-hello-world'
    }
];


var otherRepos = [
    {
        title: 'Cordova CLI',
        id: 'cli',
        repoName: 'cordova-cli',
        inactive: false, // Not on the same release schedule as the rest of Cordova
    }, {
        title: 'Cordova Plugman',
        id: 'plugman',
        repoName: 'cordova-plugman',
        inactive: true, // Not on the same release schedule as the rest of Cordova
    }, {
        title: 'Cordova Coho',
        id: 'coho',
        repoName: 'cordova-coho',
        inactive: true, // Not on the same release schedule as the rest of Cordova
    }
];

var allRepos = platformRepos.concat(nonPlatformRepos).concat(otherRepos);

var repoGroups = {
    'all': allRepos,
    'active': allRepos.filter(function(r) { return !r.inactive }),
    'auto': computeExistingRepos(),
    'inactive': allRepos.filter(function(r) { return r.inactive }),
    'platform': platformRepos,
    'active-platform': platformRepos.filter(function(r) { return !r.inactive }),
};

var performGitPush = true;
var gitPushCount = 0;

function reportGitPushResult() {
    console.log('');
    if (gitPushCount && !performGitPush) {
        console.log('All work complete. Changes were made locally. Run again with --push to push them.');
    } else if (gitPushCount) {
        console.log('All work complete. Changes were successfully pushed.');
    } else {
        console.log('All work complete. No changes were made.');
    }
}

function fatal() {
    console.error.apply(console, arguments);
    process.exit(1);
}

function registerRepoFlag(opt) {
    return opt.options('r', {
        alias: 'repo',
        desc: 'Which repos to operate on. Multiple flags allowed. This can be repo IDs or repo groups. Use the list-repos command see valid values.',
        default: 'active'
    });
}

function registerHelpFlag(opt) {
    return opt.options('h', {
        alias: 'help',
        desc: 'Shows help information.'
    });
}

var lastLoggedDir = null;
function logCwd() {
    var curDir = process.cwd();
    if (curDir != lastLoggedDir) {
        lastLoggedDir = curDir;
        console.log('Changed directory to: ' + path.relative(origWorkingDir, curDir));
    }
}

function execHelper(cmd, silent, allowError) {
    if (/^git push/.exec(cmd)) {
        gitPushCount++;
        if (!performGitPush) {
            return;
        }
    }
    if (!silent) {
        logCwd();
        console.log('Executing command:', cmd);
    }
    var result = shjs.exec(cmd, {silent: silent});
    if (result.code) {
        if (allowError) {
            return null;
        }
        process.exit(2);
    }
    return result.output.trim();
}

function cpAndLog(src, dest) {
    console.log('Coping File:', src, '->', dest);
    // Throws upon failure.
    shjs.cp('-f', src, dest);
    if (shjs.error()) {
        fatal('Copy failed.');
    }
}

function gitCheckout(branchName) {
    var curBranch = retrieveCurrentBranchName();
    if (curBranch != branchName) {
        execHelper('git checkout ' + branchName);
    }
}

var isInForEachRepoFunction = false;

function forEachRepo(repos, func) {
    repos.forEach(function(repo) {
        var origPath = isInForEachRepoFunction ? process.cwd() : '..';
        var newPath = isInForEachRepoFunction ? path.join('..', repo.repoName) : repo.repoName;

        isInForEachRepoFunction = true;
        shjs.cd(newPath);
        if (shjs.error()) {
            fatal('Repo directory does not exist: ' + repo.repoName + '. First run coho repo-clone.');
        }
        func(repo);
        shjs.cd(origPath);

        isInForEachRepoFunction = origPath != '..';
    });
}

function getRepoById(id, opt_repos) {
    var repos = opt_repos || allRepos;
    for (var i = 0; i < repos.length; ++i) {
        if (repos[i].id == id) {
            return repos[i];
        }
    }
    return null;
}

function createRepoUrl(repo) {
    return 'https://git-wip-us.apache.org/repos/asf/' + repo.repoName + '.git';
}

function createReleaseCommand(argv) {
    var opt = registerRepoFlag(optimist)
    opt = opt
        .options('new-version', {
            desc: 'The version to release. E.g. 2.7.1rc2',
            demand: true
         })
        .options('prev-version', {
            desc: 'The previous release version (used to create changelog)',
            demand: true
         })
        .options('update', {
            type: 'boolean',
            desc: 'Use --no-update to skip the "git fetch" step.',
            default: true
         })
        .options('sign', {
            type: 'boolean',
            desc: 'Use --no-sign to skip the final zip+pgp signing step.',
            default: true
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Clones all necessary repositories, and then stages the release.\n' +
               'This involves:\n' +
               '    Cloning all repositories that are not already cloned.\n' +
               '    Updating all of them via git fetch\n' +
               '    Zipping them up\n' +
               '    Adding in extra release files\n' +
               '    Zipping up all files + zips into a master zip\n' +
               '    Signing the master zip via pgp\n' +
               '\n' +
               'Usage: $0 create-release-snapshot')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var repos = computeReposFromFlag(argv);
    var prevVersion = argv['prev-version'];
    var newVersion = argv['new-version'];

    // Ensure we can find the path to the coho repo.
    var scriptPath = path.dirname(process.argv[1]);
    var keysPath = path.join(scriptPath, 'KEYS');
    var binPath = path.join(scriptPath, 'bin');
    if (!shjs.test('-f', keysPath)) {
        fatal('Expected path to exist: ' + keysPath);
    }
    if (!shjs.test('-d', binPath)) {
        fatal('Expected path to exist: ' + binPath);
    }

    cloneRepos(repos);
    if (argv.update) {
        // No need to update branches, just do a git fetch --tags.
        updateRepos(repos, [], false);
    }

    // Check that the version tags exist.
    forEachRepo(repos, function(repo) {
        if (!tagExists(prevVersion)) {
            fatal('Tag "' + prevVersion + '" does not exist in repo ' + repo.repoName);
        }
        if (!tagExists(newVersion)) {
            fatal('Tag "' + newVersion + '" does not exist in repo ' + repo.repoName);
        }
    });

    var releaseDir = path.join('releases', 'cordova-' + newVersion);
    var destDir = path.join(releaseDir, 'cordova-' + newVersion);
    shjs.rm('-rf', releaseDir);
    shjs.mkdir('-p', destDir);

    // Create zips.
    forEachRepo(repos, function(repo) {
        var zipPath = path.join('..', destDir, repo.repoName + '.zip');
        if (shjs.test('-f', zipPath)) {
            console.log('Skipping zip (already exists):', zipPath);
        } else {
            execHelper('git archive --format zip -o "' + zipPath + '" ' + newVersion);
        }
    });

    cpAndLog(keysPath, path.join(releaseDir, 'KEYS'));
    cpAndLog(path.join(binPath, '*'), destDir);

    console.log('Generating change logs...');
    var changeLogData = 'Cordova Commits from ' + prevVersion + ' -> ' + newVersion + '\n';
    forEachRepo(repos, function(repo) {
        changeLogData += '\n' + repo.repoName + '\n---\n';
        changeLogData += execHelper('git log --no-merges --format="%h %s" ' + prevVersion + '..' + newVersion, true);
    });
    fs.writeFileSync(path.join(destDir, 'changelog'), changeLogData);
    console.log('Generating final zip...');

    var cordovaSrcZip  = 'cordova-' + newVersion + '-src.zip';
    var cordovaSrcSha  = cordovaSrcZip + '.sha';

    shjs.rm('-f', path.join(releaseDir, cordovaSrcZip + '*'));
    var oldDir = shjs.pwd();
    shjs.cd(releaseDir);
    execHelper('zip -rq ' + cordovaSrcZip + ' cordova-' + newVersion);
    execHelper('gpg --armor --detach-sig --output ' + cordovaSrcZip + '.asc ' + cordovaSrcZip);
    fs.writeFileSync(cordovaSrcZip + '.md5', execHelper('gpg --print-md MD5 ' + cordovaSrcZip));
    fs.writeFileSync(cordovaSrcZip + '.sha', execHelper('gpg --print-md SHA512 ' + cordovaSrcZip));
    console.log('Final product is ready at:', path.join(releaseDir, cordovaSrcZip));
    shjs.cd(oldDir);
    process.exit(0);
}

function apacheUpload(){
    if (shjs.test('-d','./apachecordova')){
        console.log('apachecordova directory exists');
        shjs.exec("cd apachecordova && svn update");

    }else{
        //grab apachecordova repo off apache svn servers
        shjs.exec("svn checkout https://dist.apache.org/repos/dist/release/cordova apachecordova")
    }
    

    /*svn checkout https://dist.apache.org/repos/dist/release/cordova apachecordova
    add function to do rest of 
    delete all files 
    copy over release files
    svn add *
    svn commit -m*/
}

function computeReposFromFlag(argv) {
    var flagValue = argv.r;
    var values = Array.isArray(flagValue) ? flagValue : [flagValue];
    var ret = [];
    var addedIds = {};
    function addRepo(repo) {
        if (!addedIds[repo.id]) {
            addedIds[repo.id] = true;
            ret.push(repo);
        }
    }
    values.forEach(function(value) {
        var repo = getRepoById(value);
        var group = repoGroups[value];
        if (repo) {
            addRepo(repo);
        } else if (group) {
            group.forEach(addRepo);
        } else {
            fatal('Invalid repo value: ' + value + '\nUse the list-repos command to see value values.');
        }
    });
    return ret;
}

function computeExistingRepos() {
    return allRepos.filter(function(repo) {
        return shjs.test('-d', repo.repoName);
    });
}

function localBranchExists(name) {
    return !!execHelper('git branch --list ' + name, true);
}

function remoteBranchExists(repo, name) {
    return !!execHelper('git branch -r --list ' + repo.remoteName + '/' + name, true);
}

function retrieveCurrentBranchName() {
    try {
        var ret = execHelper('git symbolic-ref --short HEAD', true, true);
    } catch (e) {
        ret = execHelper('git symbolic-ref --short HEAD', true, true);
    }
    if (!ret) {
        throw new Error('Aborted due to repo ' + shjs.pwd() + ' not being on a named branch');
    }
    return ret;
}

function retrieveCurrentTagName() {
    // This will return the tag name plus commit info it not directly at a tag.
    // That's fine since all users of this function are meant to use the result
    // in an equality check.
    return execHelper('git describe --tags HEAD', true, true);
}

function tagExists(tagName) {
    return !!execHelper('git tag --list ' + tagName, true);
}

function listReposCommand(argv) {
    console.log('Valid values for the --repo flag:');
    console.log('');
    console.log('Repositories:');
    allRepos.forEach(function(repo) {
        console.log('    ' + repo.id);
    });
    console.log('');
    console.log('Repository Groups:');
    var groupNames = Object.keys(repoGroups);
    groupNames.sort();
    groupNames.forEach(function(groupName) {
        console.log('    ' + groupName + ' (' + repoGroups[groupName].map(function(repo) { return repo.id }).join(', ') + ')');
    });
    process.exit(0);
}

function repoCloneCommand(argv) {
    var opt = registerRepoFlag(optimist)
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Clones git repositories into the current working directory. If the repositories are already cloned, then this is a no-op.\n\n' +
               'Usage: $0 clone --repo=name [--repo=othername]')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var repos = computeReposFromFlag(argv);
    cloneRepos(repos);
    process.exit(0);
}

function cloneRepos(repos) {
    var failures = [];
    var numSkipped = 0;

    repos.forEach(function(repo) {
        if (shjs.test('-d', repo.repoName)) {
            console.log('Repo already cloned: ' + repo.repoName);
            numSkipped +=1 ;
        } else {
            var code = shjs.exec('git clone --progress ' + createRepoUrl(repo)).code;
            if (code) {
                failures.push(repo.repoName);
            }
        }
    });

    var numCloned = repos.length - failures.length - numSkipped;
    if (numCloned) {
        console.log('Successfully cloned ' + numCloned + ' repositories.');
    }
    if (failures.length) {
        fatal('The following repositories failed to clone: ' + failures.join(', '));
    }
}

function repoStatusCommand(argv) {
    var opt = registerRepoFlag(optimist)
    var opt = optimist
        .options('b', {
            alias: 'branch',
            desc: 'The name of the branch to report on. Can be specified multiple times to specify multiple branches.',
            default: 'master'
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Reports what changes exist locally that are not yet pushed.\n' +
               '\n' +
               'Usage: $0 repo-status -r ios -b master -b 2.9.x')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var branches = Array.isArray(argv.b) ? argv.b : [argv.b];
    var repos = computeReposFromFlag(argv);

    var logs = '';
    var diffs = '';

    forEachRepo(repos, function(repo) {
        // Determine remote name.
        updateRepos([repo], [], true);
        branches.forEach(function(branchName) {
            if (!localBranchExists(branchName)) {
                return;
            }
            gitCheckout(branchName);
            var targetBranch = remoteBranchExists(repo, branchName) ? branchName : 'master';
            var changes = execHelper('git log --oneline ' + repo.remoteName + '/' + targetBranch + '..' + branchName, true);
            if (changes) {
                logs += repo.repoName + ' on branch ' + branchName + ': Local commits exist.\n';
                logs += changes + '\n';
                diffs += 'Diff for for ' + repo.repoName + ' on branch ' + branchName + ' (truncated):\n';
                diffs += execHelper('git diff ' + repo.remoteName + '/' + targetBranch + '..' + branchName, true).split('\n').slice(0, 30).join('\n');
                diffs += '\n\n';
            } else {
                logs += repo.repoName + ' on branch ' + branchName + ': No local commits\n';
            }
        });
    });
    console.log('\n\n');
    console.log(logs);
    console.log(diffs);
}

function repoResetCommand(argv) {
    var opt = registerRepoFlag(optimist)
    var opt = optimist
        .options('b', {
            alias: 'branch',
            desc: 'The name of the branch to reset. Can be specified multiple times to specify multiple branches.',
            default: 'master'
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Resets repository branches to match their upstream state.\n' +
               'Performs the following commands on each:\n' +
               '    git reset --hard origin/$BRANCH_NAME\n' +
               '\n' +
               'Usage: $0 repo-reset -r ios -b master -b 2.9.x')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var branches = Array.isArray(argv.b) ? argv.b : [argv.b];
    var repos = computeReposFromFlag(argv);

    // Pre-fetch checks.
    forEachRepo(repos, function(repo) {
        // Determine remote name.
        updateRepos([repo], [], true);
        stashAndPop(repo, function() {
            branches.forEach(function(branchName) {
                if (!localBranchExists(branchName)) {
                    return;
                }
                gitCheckout(branchName);
                var changes = execHelper('git log --oneline ' + repo.remoteName + '/' + branchName + '..' + branchName);
                if (changes) {
                    console.log(repo.repoName + ' on branch ' + branchName + ': Local commits exist. Resetting.\n');
                    execHelper('git reset --hard ' + repo.remoteName + '/' + branchName);
                } else {
                    console.log(repo.repoName + ' on branch ' + branchName + ': No local commits exist.\n');
                }
            });
        });
    });
}

function repoUpdateCommand(argv) {
    var opt = registerRepoFlag(optimist)
    var opt = opt
        .options('b', {
            alias: 'branch',
            desc: 'The name of the branch to update. Can be specified multiple times to update multiple branches.',
            default: 'master'
         })
        .options('fetch', {
            type: 'boolean',
            desc: 'Use --no-fetch to skip the "git fetch" step.',
            default: true
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Updates git repositories by performing the following commands:\n' +
               '    save active branch\n' +
               '    git fetch $REMOTE \n' +
               '    git stash\n' +
               '    for each specified branch:\n' +
               '        git checkout $BRANCH\n' +
               '        git rebase $REMOTE/$BRANCH\n' +
               '        git checkout -\n' +
               '    git checkout $SAVED_ACTIVE_BRANCH\n' +
               '    git stash pop\n' +
               '\n' +
               'Usage: $0 repo-update')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var branches = Array.isArray(argv.b) ? argv.b : [argv.b];
    var repos = computeReposFromFlag(argv);

    updateRepos(repos, branches, !argv.fetch);
    process.exit(0);
}

function determineApacheRemote(repo) {
    var fields = execHelper('git remote -v', true).split(/\s+/);
    for (var i = 1; i < fields.length; i += 3) {
        if (fields[i].indexOf('git-wip-us.apache.org/repos/asf/' + repo.repoName) != -1) {
            return fields[i - 1];
        }
    }
    fatal('Could not find an apache remote for repo ' + repo.repoName);
}

function pendingChangesExist() {
    return !!execHelper('git status --porcelain', true);
}

function stashAndPop(repo, func) {
    var requiresStash = pendingChangesExist();

    if (requiresStash) {
        execHelper('git stash save --all --quiet "coho stash"');
    }

    func();

    if (requiresStash) {
        execHelper('git stash pop');
    }
}

function updateRepos(repos, branches, noFetch) {
    // Pre-fetch checks.
    forEachRepo(repos, function(repo) {
        // Ensure it's on a named branch.
        retrieveCurrentBranchName();
        // Find the apache remote.
        if (!repo.remoteName) {
            repo.remoteName = determineApacheRemote(repo);
        }
    });

    if (!noFetch) {
        forEachRepo(repos, function(repo) {
            // TODO - can these be combined? Fetching with --tags seems to not pull in changes...
            execHelper('git fetch --progress ' + repo.remoteName);
            execHelper('git fetch --progress --tags ' + repo.remoteName);
        });
    }

    if (branches && branches.length) {
        forEachRepo(repos, function(repo) {
            var staleBranches = branches.filter(function(branchName) {
                var curHash = execHelper('git rev-parse ' + branchName, true, true);
                var newHash = execHelper('git rev-parse ' + repo.remoteName + '/' + branchName, true, true);
                return curHash !== newHash;
            });
            if (!staleBranches.length) {
                console.log('Repo already up-to-date: ' + repo.repoName);
            } else {
                console.log('Updating ' + repo.repoName);
                stashAndPop(repo, function() {
                    staleBranches.forEach(function(branchName) {
                        if (!remoteBranchExists(repo, branchName)) {
                            console.warning('Skipping branch. Remote branch "' + branchName + '" does not exist.');
                        } else {
                            gitCheckout(branchName);
                            execHelper('git rebase ' + repo.remoteName + '/' + branchName);
                        }
                    });
                });
            }
        });
    }
}

function configureReleaseCommandFlags(opt) {
    var opt = registerRepoFlag(opt)
    opt = opt
        .options('version', {
            desc: 'The version to use for the branch. Must match the pattern #.#.#[rc#]',
            demand: true
         })
        .options('push', {
            desc: 'Whether to git push changes. Defaults to false.',
         });
    opt = registerHelpFlag(opt);
    argv = opt.argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var version = argv.version;
    if (!/^\d+\.\d+\.\d+(rc\d)?$/.test(version)) {
        fatal('The version must be in the form #.#.#[rc#]');
    }
    return argv;
}

var hasRunJake = false;

function updateJsSnapshot(repo, version, branchName) {
    function ensureJsIsBuilt() {
        var cordovaJsRepo = getRepoById('js');
        if (!hasRunJake) {
            forEachRepo([cordovaJsRepo], function() {
                var actualCurTag = retrieveCurrentTagName();
                if (actualCurTag != version) {
                    fatal('Not preparing branches since cordova-js is not at the version tag. (it\'s at ' + actualCurTag + ')');
                }
                execHelper('jake');
                hasRunJake = true;
            });
        }
    }

    if (platformRepos.indexOf(repo) == -1) {
        return;
    }

    if (repo.cordovaJsPaths) {
        ensureJsIsBuilt();
        repo.cordovaJsPaths.forEach(function(jsPath) {
            var src = path.join('..', 'cordova-js', 'pkg', repo.cordovaJsSrcName || ('cordova.' + repo.id + '.js'));
            cpAndLog(src, jsPath);
        });
        // Extra bb10 logic
        if (repo.id == 'blackberry') {
            var src = path.join('..', 'cordova-js', 'pkg', 'cordova.blackberry10.js');
            cpAndLog(src, path.join('blackberry10', 'javascript', 'cordova.blackberry10.js'));
        }
        if (pendingChangesExist()) {
            execHelper('git commit -am "Update JS snapshot to version ' + version + ' (via coho)"');
            execHelper('git push ' + repo.remoteName + ' ' + branchName);
        }
    } else if (allRepos.indexOf(repo) != -1) {
        console.log('*** DO NOT KNOW HOW TO UPDATE cordova.js FOR THIS REPO ***');
    }
}

function prepareReleaseBranchCommand() {
    var argv = configureReleaseCommandFlags(optimist
        .usage('Prepares release branches but does not create tags. This includes:\n' +
               '    1. Creating the branch if it doesn\'t already exist\n' +
               '    2. Updating cordova.js snapshot and VERSION file.\n' +
               '\n' +
               'Command is safe to run multiple times, and can be run for the purpose\n' +
               'of checking out existing release branches.\n' +
               '\n' +
               'Command can also be used to update the JS snapshot after release \n' +
               'branches have been created.\n' +
               '\n' +
               'Usage: $0 prepare-release-branch --version=2.8.0rc1')
    );
    var repos = computeReposFromFlag(argv);
    var version = argv.version;
    // performGitPush = argv.push;
    var branchName = version.replace(/\d+(rc\d)?$/, 'x');

    // First - perform precondition checks.
    updateRepos(repos, [], true);

    var cordovaJsRepo = getRepoById('js');

    // Ensure cordova-js comes first.
    var repoIndex = repos.indexOf(cordovaJsRepo);
    if (repoIndex != -1) {
        repos.splice(repoIndex, 1);
        repos.unshift(cordovaJsRepo);
    }

    forEachRepo(repos, function(repo) {
        stashAndPop(repo, function() {
            // git fetch + update master
            updateRepos([repo], ['master'], false);
            gitCheckout('master');
            // Update JS on master.
            updateJsSnapshot(repo, version, 'master');

            // Either create or pull down the branch.
            if (remoteBranchExists(repo, branchName)) {
                console.log('Remote branch already exists for repo: ' + repo.repoName);
                // Check out and rebase.
                updateRepos([repo], [branchName], true);
                gitCheckout(branchName);
                // Update JS on branch.
                updateJsSnapshot(repo, version, branchName);
            } else {
                execHelper('git checkout -b ' + branchName);
                execHelper('git push --set-upstream ' + repo.remoteName + ' ' + branchName);
            }
            // Update the VERSION files.
            var versionFilePaths = repo.versionFilePaths || ['VERSION'];
            if (fs.existsSync(versionFilePaths[0])) {
                console.log(repo.repoName + ': ' + 'Updating VERSION file.');
                versionFilePaths.forEach(function(versionFilePath) {
                    fs.writeFileSync(versionFilePath, version + '\n');
                });
                if (repo.id == 'android') {
                    shjs.sed('-i', /cordovaVersion.*=.*;/, 'cordovaVersion = "' + version + '";', path.join('framework', 'src', 'org', 'apache', 'cordova', 'Device.java'));
                }
                if (!pendingChangesExist()) {
                    console.log('VERSION file was already up-to-date.');
                }
            } else {
                console.warn('No VERSION file exists in repo ' + repo.repoName);
            }

            if (pendingChangesExist()) {
                execHelper('git commit -am "Set VERSION to ' + version + ' (via coho)"');
                execHelper('git push ' + repo.remoteName + ' ' + branchName);
            }
        });
    });

    reportGitPushResult();
}

function tagReleaseBranchCommand(argv) {
    var argv = configureReleaseCommandFlags(optimist
        .usage('Tags a release branches.\n' +
               '\n' +
               'Usage: $0 tag-release --version=2.8.0rc1')
    );
    var repos = computeReposFromFlag(argv);
    var version = argv.version;
    // performGitPush = argv.push;
    var branchName = version.replace(/\d+(rc\d)?$/, 'x');

    // First - perform precondition checks.
    updateRepos(repos, [], true);

    forEachRepo(repos, function(repo) {
        stashAndPop(repo, function() {
            // git fetch.
            updateRepos([repo], [], false);

            if (remoteBranchExists(repo, branchName)) {
                console.log('Remote branch already exists for repo: ' + repo.repoName);
                gitCheckout(branchName);
            } else {
                fatal('Release branch does not exist for repo ' + repo.repoName);
            }

            // git merge
            updateRepos([repo], [branchName], true);

            // Create/update the tag.
            var tagName = retrieveCurrentTagName();
            if (tagName != version) {
                if (tagExists(version)) {
                    execHelper('git tag ' + version + ' --force');
                } else {
                    execHelper('git tag ' + version);
                }
                execHelper('git push --tags ' + repo.remoteName + ' ' + branchName);
            } else {
                console.log('Repo ' + repo.repoName + ' is already tagged.');
            }
        });
    });

    reportGitPushResult();
}

function ratCommand() {
    var opt = registerRepoFlag(optimist);
    opt = registerHelpFlag(opt);
    opt.usage('Uses Apache RAT to audit source files for license headers.\n' +
              '\n' +
              'Usage: $0 audit-license-headers --repo=ios')
    argv = opt.argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var repos = computeReposFromFlag(argv);
    // Check that RAT command exists.
    var ratPath = path.resolve(path.join(path.dirname(process.argv[1]), 'apache-rat-0.8', 'apache-rat-0.8.jar'));
    if (!fs.existsSync(ratPath)) {
        console.log('RAT tool not found, downloading to: ' + ratPath);
        forEachRepo([getRepoById('coho')], function() {
            if (shjs.which('curl')) {
                execHelper('curl "http://mirror.csclub.uwaterloo.ca/apache/incubator/rat/binaries/apache-rat-incubating-0.8-bin.tar.gz" | tar xz');
            } else {
                execHelper('wget -O - "http://mirror.csclub.uwaterloo.ca/apache/incubator/rat/binaries/apache-rat-incubating-0.8-bin.tar.gz" | tar xz');
            }
        });
        if (!fs.existsSync(ratPath)) {
            fatal('Download failed.');
        }
    }
    forEachRepo(repos, function(repo) {
        var allExcludes = COMMON_RAT_EXCLUDES;
        if (repo.ratExcludes) {
            allExcludes = allExcludes.concat(repo.ratExcludes);
        }
        var excludeFlags = '-e "' + allExcludes.join('" -e "') + '"';
        execHelper('java -jar "' + ratPath + '" -d . ' + excludeFlags);
    });
}

function main() {
    var commandList = [
        {
            name: 'repo-clone',
            desc: 'Clones git repositories into the current working directory.',
            entryPoint: repoCloneCommand
        }, {
            name: 'repo-update',
            desc: 'Performs git pull --rebase on all specified repositories.',
            entryPoint: repoUpdateCommand
        }, {
            name: 'repo-reset',
            desc: 'Performs git reset --hard origin/$BRANCH on all specified repositories.',
            entryPoint: repoResetCommand
        }, {
            name: 'repo-status',
            desc: 'Lists changes that exist locally but have not yet been pushed.',
            entryPoint: repoStatusCommand
        }, {
            name: 'list-repos',
            desc: 'Shows a list of valid values for the --repo flag.',
            entryPoint: listReposCommand
        }, {
            name: 'prepare-release-branch',
            desc: 'Branches, updates JS, updates VERSION. Safe to run multiple times.',
            entryPoint: prepareReleaseBranchCommand
        }, {
            name: 'tag-release',
            desc: 'Tags repos for a release.',
            entryPoint: tagReleaseBranchCommand
        }, {
            name: 'audit-license-headers',
            desc: 'Uses Apache RAT to look for missing license headers.',
            entryPoint: ratCommand
        }, {
            name: 'create-release-snapshot',
            desc: 'Creates a signed .zip that consitutes a release.',
            entryPoint: createReleaseCommand
        }
//            name: 'upload-release',
//            desc: 'Uploads a signed .zip to Cordova\'s webserver.',
//            entryPoint: null
    ];
    var commandMap = {};
    for (var i = 0; i < commandList.length; ++i) {
        commandMap[commandList[i].name] = commandList[i];
    }
    var usage = 'Usage: $0 command [options]\n' +
               '\n' +
               'Valid commands:\n';
    for (var i = 0; i < commandList.length; ++i) {
        usage += '    ' + commandList[i].name + ': ' + commandList[i].desc + '\n';
    }
    usage += '\nFor help on a specific command: $0 command --help';

    var command;
    var argv = optimist
        .usage(usage)
        .check(function(argv) {
            command = argv._[0];
            if (!command) {
                throw 'No command specified.';
            }
            if (!commandMap[command]) {
                throw 'Unknown command: ' + command;
            }
        }).argv;

    // ShellJS opens a lot of file handles, and the default on OS X is too small.
    var ulimit = execHelper('ulimit -S -n', true, true);
    if (ulimit && ulimit < 2000) {
        execHelper('/bin/bash -c \'ulimit -S -n 4096; exec "' + process.argv[0] + '" "' + process.argv.slice(1).join('" "') + '" --ulimit\'');
        return;
    }

    commandMap[command].entryPoint();
}
main();
