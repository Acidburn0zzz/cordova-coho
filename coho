#!/usr/bin/env node
/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/

var fs = require('fs');
var optimist = require('optimist');
var path = require('path');
var shjs = require('shelljs');

var origWorkingDir = process.cwd();

var platformRepos = [
    {
        title: 'Android',
        id: 'android',
        repoName: 'cordova-android',
        cordovaJsPaths: ['framework/assets/www/cordova.js']
    }, {
        title: 'iOS',
        id: 'ios',
        repoName: 'cordova-ios',
        cordovaJsPaths: ['CordovaLib/cordova.js']
    }, {
        title: 'BlackBerry',
        id: 'blackberry',
        repoName: 'cordova-blackberry'
    }, {
        title: 'Windows',
        id: 'windows',
        repoName: 'cordova-windows'
    }, {
        title: 'Windows Phone 7',
        id: 'wp7',
        repoName: 'cordova-wp7',
        cordovaJsSrcName: 'cordova.windowsphone.js',
        cordovaJsPaths: ['templates/standalone/www/cordova.js', 'example/www/cordova.js']
    }, {
        title: 'Windows Phone 8',
        id: 'wp8',
        repoName: 'cordova-wp8',
        cordovaJsSrcName: 'cordova.windowsphone.js',
        cordovaJsPaths: ['templates/standalone/www/cordova.js', 'example/www/cordova.js']
    }, {
        title: 'Mac OSX',
        id: 'osx',
        repoName: 'cordova-osx',
        cordovaJsPaths: ['CordovaFramework/cordova.js']
    }, {
        title: 'Bada',
        id: 'bada',
        repoName: 'cordova-bada',
        inactive: true
    }, {
        title: 'Bada WAC',
        id: 'bada-wac',
        repoName: 'cordova-bada-wac',
        inactive: true
    }, {
        title: 'WebOS',
        id: 'webos',
        repoName: 'cordova-webos',
        inactive: true
    }, {
        title: 'QT',
        id: 'qt',
        repoName: 'cordova-qt',
        inactive: true
    }, {
        title: 'Tizen',
        id: 'tizen',
        repoName: 'cordova-tizen',
        inactive: true
    }
];

var nonPlatformRepos = [
    {
        title: 'Docs',
        id: 'docs',
        repoName: 'cordova-docs'
    }, {
        title: 'MobileSpec',
        id: 'mobile-spec',
        repoName: 'cordova-mobile-spec'
    }, {
        title: 'Cordova JS',
        id: 'js',
        repoName: 'cordova-js'
    }, {
        title: 'Hello World App',
        id: 'app-hello-world',
        repoName: 'cordova-app-hello-world'
    }
];


var otherRepos = [
    {
        title: 'Cordova CLI',
        id: 'cli',
        repoName: 'cordova-cli',
        inactive: true, // Not on the same release schedule as the rest of Cordova
    }, {
        title: 'Cordova Plugman',
        id: 'plugman',
        repoName: 'cordova-plugman',
        inactive: true, // Not on the same release schedule as the rest of Cordova
    }, {
        title: 'Cordova Coho',
        id: 'coho',
        repoName: 'cordova-coho',
        inactive: true, // Not on the same release schedule as the rest of Cordova
    }
];

var allRepos = platformRepos.concat(nonPlatformRepos).concat(otherRepos);

var repoGroups = {
    'all': allRepos,
    'active': allRepos.filter(function(r) { return !r.inactive }),
    'inactive': allRepos.filter(function(r) { return r.inactive }),
    'platform': platformRepos,
    'active-platform': platformRepos.filter(function(r) { return !r.inactive }),
};

function fatal() {
    console.error.apply(console, arguments);
    process.exit(1);
}

function registerRepoFlag(opt) {
    return opt.options('r', {
        alias: 'repo',
        desc: 'Which repos to operate on. Multiple flags allowed. This can be repo IDs or repo groups. Use the list-repos command see valid values.',
        default: 'active'
    });
}

function registerHelpFlag(opt) {
    return opt.options('h', {
        alias: 'help',
        desc: 'Shows help information.'
    });
}

var lastLoggedDir = null;
function logCwd() {
    var curDir = process.cwd();
    if (curDir != lastLoggedDir) {
        lastLoggedDir = curDir;
        console.log('Changed directory to: ' + path.relative(origWorkingDir, curDir));
    }
}

function execHelper(cmd, silent, allowError) {
    if (!silent) {
        logCwd();
        console.log('Executing command:', cmd);
    }
    var result = shjs.exec(cmd, {silent: silent});
    if (result.code) {
        if (allowError) {
            return null;
        }
        process.exit(2);
    }
    return result.output.trim();
}

function cpAndLog(src, dest) {
    console.log('Coping File:', src, '->', dest);
    // Throws upon failure.
    shjs.cp('-f', src, dest);
    if (shjs.error()) {
        fatal('Copy failed.');
    }
}

var isInForEachRepoFunction = false;

function forEachRepo(repos, func) {
    repos.forEach(function(repo) {
        var origPath = isInForEachRepoFunction ? process.cwd() : '..';
        var newPath = isInForEachRepoFunction ? path.join('..', repo.repoName) : repo.repoName;

        isInForEachRepoFunction = true;
        shjs.cd(newPath);
        if (shjs.error()) {
            fatal('Repo directory does not exist: ' + repo.repoName + '. First run coho repo-clone.');
        }
        func(repo);
        shjs.cd(origPath);

        isInForEachRepoFunction = origPath != '..';
    });
}

function getRepoById(id, opt_repos) {
    var repos = opt_repos || allRepos;
    for (var i = 0; i < repos.length; ++i) {
        if (repos[i].id == id) {
            return repos[i];
        }
    }
    return null;
}

function createRepoUrl(repo) {
    return 'https://git-wip-us.apache.org/repos/asf/' + repo.repoName + '.git';
}

function createReleaseCommand(argv) {
    var opt = registerRepoFlag(optimist)
    opt = opt
        .options('new-version', {
            desc: 'The version to release. E.g. 2.7.1rc2',
            demand: true
         })
        .options('prev-version', {
            desc: 'The previous release version (used to create changelog)',
            demand: true
         })
        .options('update', {
            type: 'boolean',
            desc: 'Use --no-update to skip the "git fetch" step.',
            default: true
         })
        .options('sign', {
            type: 'boolean',
            desc: 'Use --no-sign to skip the final zip+pgp signing step.',
            default: true
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Clones all necessary repositories, and then stages the release.\n' +
               'This involves:\n' +
               '    Cloning all repositories that are not already cloned.\n' +
               '    Updating all of them via git fetch\n' +
               '    Zipping them up\n' +
               '    Adding in extra release files\n' +
               '    Zipping up all files + zips into a master zip\n' +
               '    Signing the master zip via pgp\n' +
               '\n' +
               'Usage: $0 create-release-snapshot')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var repos = computeReposFromFlag(argv);
    var prevVersion = argv['prev-version'];
    var newVersion = argv['new-version'];

    // Ensure we can find the path to the coho repo.
    var scriptPath = path.dirname(process.argv[1]);
    var keysPath = path.join(scriptPath, 'KEYS');
    var binPath = path.join(scriptPath, 'bin');
    if (!shjs.test('-f', keysPath)) {
        fatal('Expected path to exist: ' + keysPath);
    }
    if (!shjs.test('-d', binPath)) {
        fatal('Expected path to exist: ' + binPath);
    }

    cloneRepos(repos);
    if (argv.update) {
        // No need to update branches, just do a git fetch --tags.
        updateRepos(repos, [], false);
    }

    // Check that the version tags exist.
    forEachRepo(repos, function(repo) {
        if (!tagExists(prevVersion)) {
            fatal('Tag "' + prevVersion + '" does not exist in repo ' + repo.repoName);
        }
        if (!tagExists(newVersion)) {
            fatal('Tag "' + newVersion + '" does not exist in repo ' + repo.repoName);
        }
    });

    var releaseDir = path.join('releases', 'cordova-' + newVersion);
    var destDir = path.join(releaseDir, 'cordova-' + newVersion);
    shjs.rm('-rf', releaseDir);
    shjs.mkdir('-p', destDir);

    // Create zips.
    forEachRepo(repos, function(repo) {
        var zipPath = path.join('..', destDir, repo.repoName + '.zip');
        if (shjs.test('-f', zipPath)) {
            console.log('Skipping zip (already exists):', zipPath);
        } else {
            execHelper('git archive --format zip -o "' + zipPath + '" ' + newVersion);
        }
    });

    cpAndLog(keysPath, path.join(releaseDir, 'KEYS'));
    cpAndLog(path.join(binPath, '*'), destDir);

    console.log('Generating change logs...');
    var changeLogData = 'Cordova Commits from ' + prevVersion + ' -> ' + newVersion + '\n';
    forEachRepo(repos, function(repo) {
        changeLogData += '\n' + repo.repoName + '\n---\n';
        changeLogData += execHelper('git log --no-merges --format="%h %s" ' + prevVersion + '..' + newVersion, true);
    });
    fs.writeFileSync(path.join(destDir, 'changelog'), changeLogData);
    console.log('Generating final zip...');

    var cordovaSrcZip  = 'cordova-' + newVersion + '-src.zip';
    var cordovaSrcSha  = cordovaSrcZip + '.sha';

    shjs.rm('-f', path.join(releaseDir, cordovaSrcZip + '*'));
    var oldDir = shjs.pwd();
    shjs.cd(releaseDir);
    execHelper('zip -rq ' + cordovaSrcZip + ' cordova-' + newVersion);
    execHelper('gpg --armor --detach-sig --output ' + cordovaSrcZip + '.asc ' + cordovaSrcZip);
    fs.writeFileSync(cordovaSrcZip + '.md5', execHelper('gpg --print-md MD5 ' + cordovaSrcZip));
    fs.writeFileSync(cordovaSrcZip + '.sha', execHelper('gpg --print-md SHA512 ' + cordovaSrcZip));
    console.log('Final product is ready at:', path.join(releaseDir, cordovaSrcZip));
    shjs.cd(oldDir);
    process.exit(0);
}

function apacheUpload(){
    if (shjs.test('-d','./apachecordova')){
        console.log('apachecordova directory exists');
        shjs.exec("cd apachecordova && svn update");

    }else{
        //grab apachecordova repo off apache svn servers
        shjs.exec("svn checkout https://dist.apache.org/repos/dist/release/cordova apachecordova")
    }
    

    /*svn checkout https://dist.apache.org/repos/dist/release/cordova apachecordova
    add function to do rest of 
    delete all files 
    copy over release files
    svn add *
    svn commit -m*/
}

function computeReposFromFlag(argv) {
    var flagValue = argv.r;
    var values = Array.isArray(flagValue) ? flagValue : [flagValue];
    var ret = [];
    var addedIds = {};
    function addRepo(repo) {
        if (!addedIds[repo.id]) {
            addedIds[repo.id] = true;
            ret.push(repo);
        }
    }
    values.forEach(function(value) {
        var repo = getRepoById(value);
        var group = repoGroups[value];
        if (repo) {
            addRepo(repo);
        } else if (group) {
            group.forEach(addRepo);
        } else {
            fatal('Invalid repo value: ' + value + '\nUse the list-repos command to see value values.');
        }
    });
    return ret;
}

function computeExistingRepos() {
    return allRepos.filter(function(repo) {
        return shjs.test('-d', repo.repoName);
    });
}

function remoteBranchExists(repo, name) {
    return !!execHelper('git branch -r --list ' + repo.remoteName + '/' + name, true);
}

function retrieveCurrentBranchName() {
    var ret = execHelper('git symbolic-ref --short HEAD', true, true);
    if (!ret) {
        throw new Error('Aborted due to repo ' + shjs.pwd() + ' not being on a named branch');
    }
}

function retrieveCurrentTagName() {
    // This will return the tag name plus commit info it not directly at a tag.
    // That's fine since all users of this function are meant to use the result
    // in an equality check.
    return execHelper('git describe --tags HEAD', true, true);
}

function tagExists(tagName) {
    return !!execHelper('git tag --list ' + tagName, true);
}

function listReposCommand(argv) {
    console.log('Valid values for the --repo flag:');
    console.log('');
    console.log('Repositories:');
    allRepos.forEach(function(repo) {
        console.log('    ' + repo.id);
    });
    console.log('');
    console.log('Repository Groups:');
    var groupNames = Object.keys(repoGroups);
    groupNames.sort();
    groupNames.forEach(function(groupName) {
        console.log('    ' + groupName + ' (' + repoGroups[groupName].map(function(repo) { return repo.id }).join(', ') + ')');
    });
    process.exit(0);
}

function repoCloneCommand(argv) {
    var opt = registerRepoFlag(optimist)
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Clones git repositories into the current working directory. If the repositories are already cloned, then this is a no-op.\n\n' +
               'Usage: $0 clone --repo=name [--repo=othername]')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var repos = computeReposFromFlag(argv);
    cloneRepos(repos);
    process.exit(0);
}

function cloneRepos(repos) {
    var failures = [];
    var numSkipped = 0;

    repos.forEach(function(repo) {
        if (shjs.test('-d', repo.repoName)) {
            console.log('Repo already cloned: ' + repo.repoName);
            numSkipped +=1 ;
        } else {
            var code = shjs.exec('git clone --progress ' + createRepoUrl(repo)).code;
            if (code) {
                failures.push(repo.repoName);
            }
        }
    });

    var numCloned = repos.length - failures.length - numSkipped;
    if (numCloned) {
        console.log('Successfully cloned ' + numCloned + ' repositories.');
    }
    if (failures.length) {
        fatal('The following repositories failed to clone: ' + failures.join(', '));
    }
}

function repoUpdateCommand(argv) {
    var opt = optimist
        .options('b', {
            alias: 'branch',
            desc: 'The name of the branch to update. Can be specified multiple times to update multiple branches.',
            default: 'master'
         })
        .options('fetch', {
            type: 'boolean',
            desc: 'Use --no-fetch to skip the "git fetch" step.',
            default: true
         });
    opt = registerHelpFlag(opt);
    var argv = opt
        .usage('Updates all existing git repositories within the current working directory.\n' +
               'Performs the following commands on each:\n' +
               '    save active branch\n' +
               '    git fetch $REMOTE \n' +
               '    git stash\n' +
               '    for each specified branch:\n' +
               '        git checkout $BRANCH\n' +
               '        git rebase $REMOTE/$BRANCH\n' +
               '        git checkout -\n' +
               '    git checkout $SAVED_ACTIVE_BRANCH\n' +
               '    git stash pop\n' +
               '\n' +
               'Usage: $0 repo-update')
        .argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var branches = Array.isArray(argv.b) ? argv.b : [argv.b];
    var repos = computeExistingRepos();
    if (repos.length === 0) {
        fatal('No repos found. Clone some using the repo-clone command.');
    }
    updateRepos(repos, branches, !argv.f);
    process.exit(0);
}

function determineApacheRemote(repo) {
    var fields = execHelper('git remote -v', true).split(/\s+/);
    for (var i = 1; i < fields.length; i += 3) {
        if (fields[i].indexOf('git-wip-us.apache.org/repos/asf/' + repo.repoName) != -1) {
            return fields[i - 1];
        }
    }
    fatal('Could not find an apache remote for repo ' + repo.repoName);
}

function pendingChangesExist() {
    return !!execHelper('git status --porcelain', true);
}

function stashAndPop(repo, func) {
    var requiresStash = pendingChangesExist();

    if (requiresStash) {
        execHelper('git stash save --all --quiet "coho stash"');
    }

    func();

    if (requiresStash) {
        execHelper('git stash pop');
    }
}

function updateRepos(repos, branches, noFetch) {
    // Pre-fetch checks.
    forEachRepo(repos, function(repo) {
        // Ensure it's on a named branch.
        retrieveCurrentBranchName();
        // Find the apache remote.
        if (!repo.remoteName) {
            repo.remoteName = determineApacheRemote(repo);
        }
    });

    if (!noFetch) {
        forEachRepo(repos, function(repo) {
            // TODO - can these be combined? Fetching with --tags seems to not pull in changes...
            execHelper('git fetch --progress ' + repo.remoteName);
            execHelper('git fetch --progress --tags ' + repo.remoteName);
        });
    }

    if (branches && branches.length) {
        forEachRepo(repos, function(repo) {
            var staleBranches = branches.filter(function(branchName) {
                var curHash = execHelper('git rev-parse ' + branchName, true, true);
                var newHash = execHelper('git rev-parse ' + repo.remoteName + '/' + branchName, true, true);
                return curHash !== newHash;
            });
            if (!staleBranches.length) {
                console.log('Repo already up-to-date: ' + repo.repoName);
            } else {
                console.log('Updating ' + repo.repoName);
                var curBranch = retrieveCurrentBranchName();
                stashAndPop(repo, function() {
                    staleBranches.forEach(function(branchName) {
                        if (!remoteBranchExists(repo, branchName)) {
                            console.warning('Skipping branch. Remote branch "' + branchName + '" does not exist.');
                        } else {
                            if (curBranch != branchName) {
                                execHelper('git checkout ' + branchName);
                                curBranch = branchName;
                            }
                            execHelper('git rebase ' + repo.remoteName + '/' + branchName);
                        }
                    });
                });
            }
        });
    }
}

function configureReleaseCommandFlags(opt) {
    var opt = registerRepoFlag(opt)
    opt = opt
        .options('version', {
            desc: 'The version to use for the branch. Must match the pattern #.#.#[rc#]',
            demand: true
         });
    opt = registerHelpFlag(opt);
    argv = opt.argv;

    if (argv.h) {
        optimist.showHelp();
        process.exit(1);
    }
    var version = argv.version;
    if (!/^\d+\.\d+\.\d+(rc\d)?$/.test(version)) {
        fatal('The version must be in the form #.#.#[rc#]');
    }
    return argv;
}

function createReleaseBranchCommand() {
    var argv = configureReleaseCommandFlags(optimist
        .usage('Prepares release branches but does not create tags. This includes:\n' +
               '    1. Creating the branch if it doesn\'t already exist\n' +
               '    2. Updating cordova.js snapshot and VERSION file.\n' +
               '\n' +
               'Command is safe to run multiple times.\n' +
               '\n' +
               'Usage: $0 create-release-branch --version=2.8.0rc1')
    );
    var repos = computeReposFromFlag(argv);
    var version = argv.version;
    var branchName = version.replace(/\d+(rc\d)?$/, 'x');

    // First - perform precondition checks.
    updateRepos(repos, [], true);

    var hasRunJake = false;
    function ensureJsIsBuilt() {
        var cordovaJs = getRepoById('js');
        forEachRepo([cordovaJs], function() {
            var actualCurTag = retrieveCurrentTagName();
            if (actualCurTag != version) {
                fatal('Not preparing branches since cordova-js is not at the version tag. (it\'s at ' + actualCurTag + ')');
            }
            if (!hasRunJake) {
                execHelper('jake');
                hasRunJake = true;
            }
        });
    }

    forEachRepo(repos, function(repo) {
        stashAndPop(repo, function() {
            // git fetch + update master
            updateRepos([repo], ['master'], false);

            if (platformRepos.indexOf(repo) != -1) {
                if (repo.cordovaJsPaths) {
                    ensureJsIsBuilt();
                    repo.cordovaJsPaths.forEach(function(jsPath) {
                        var src = path.join('..', 'cordova-js', 'pkg', repo.cordovaJsSrcName || ('cordova.' + repo.id + '.js'));
                        cpAndLog(src, jsPath);
                    });
                    if (pendingChangesExist()) {
                        execHelper('git commit -am "Update JS snapshot to version ' + version + '"');
                        execHelper('git push ' + repo.remoteName + ' master');
                    }
                } else if (allRepos.indexOf(repo) != -1) {
                    console.log('*** DO NOT KNOW HOW TO UPDATE cordova.js FOR THIS REPO ***');
                }
            }

            // Either create or pull down the branch.
            if (remoteBranchExists(repo, branchName)) {
                console.log('Remote branch already exists for repo: ' + repo.repoName);
                execHelper('git checkout ' + branchName);
                updateRepos([repo], [branchName], true);
            } else {
                execHelper('git checkout -b ' + branchName);
                execHelper('git push --set-upstream ' + repo.remoteName + ' ' + branchName);
            }
            // Update the VERSION files.
            var versionFilePath = 'VERSION';
            if (repo.id == 'ios') {
                versionFilePath = 'CordovaLib/VERSION';
            }
            if (fs.existsSync(versionFilePath)) {
                console.log(repo.repoName + ': ' + 'Updating VERSION file.');
                fs.writeFileSync(versionFilePath, version + '\n');
                if (repo.id == 'android') {
                    shjs.sed('-i', /cordovaVersion.*=.*;/, 'cordovaVersion = "' + version + '";', 'framework/src/org/apache/cordova/Device.java');
                }
                if (!pendingChangesExist()) {
                    console.log('VERSION file was already up-to-date.');
                }
            } else {
                console.warn('No VERSION file exists in repo ' + repo.repoName);
            }

            if (pendingChangesExist()) {
                execHelper('git commit -am "Set VERSION to ' + version + '"');
                execHelper('git push ' + repo.remoteName + ' ' + branchName);
            }
        });
    });
}

function tagReleaseBranchCommand(argv) {
    var argv = configureReleaseCommandFlags(optimist
        .usage('Tags a release branches.\n' +
               '\n' +
               'Usage: $0 tag-release --version=2.8.0rc1')
    );
    var repos = computeReposFromFlag(argv);
    var version = argv.version;
    var branchName = version.replace(/\d+(rc\d)?$/, 'x');

    // First - perform precondition checks.
    updateRepos(repos, [], true);

    forEachRepo(repos, function(repo) {
        stashAndPop(repo, function() {
            // git fetch.
            updateRepos([repo], [], false);

            if (remoteBranchExists(repo, branchName)) {
                console.log('Remote branch already exists for repo: ' + repo.repoName);
                execHelper('git checkout ' + branchName);
            } else {
                fatal('Release branch does not exist for repo ' + repo.repoName);
            }

            // git merge
            updateRepos([repo], [branchName], true);

            // Create/update the tag.
            var tagName = retrieveCurrentTagName();
            if (tagName != version) {
                requiresPush = true;
                if (tagExists(version)) {
                    execHelper('git tag ' + version + ' --force');
                } else {
                    execHelper('git tag ' + version);
                }
                execHelper('git push --tags ' + repo.remoteName + ' ' + branchName);
            } else {
                console.log('Repo ' + repo.repoName + ' is already tagged.');
            }
        });
    });
}

function main() {
    var commandList = [
        {
            name: 'repo-clone',
            desc: 'Clones git repositories into the current working directory.',
            entryPoint: repoCloneCommand
        }, {
            name: 'repo-update',
            desc: 'Updates all cordova git repos in the current working directory.',
            entryPoint: repoUpdateCommand
        }, {
            name: 'list-repos',
            desc: 'Shows a list of valid values for the --repo flag.',
            entryPoint: listReposCommand
        }, {
            name: 'create-release-branch',
            desc: 'Branches, updates JS, updates VERSION.',
            entryPoint: createReleaseBranchCommand
        }, {
            name: 'tag-release',
            desc: 'Tags repos for a release.',
            entryPoint: tagReleaseBranchCommand
        }, {
            name: 'create-release-snapshot',
            desc: 'Creates a signed .zip that consitutes a release.',
            entryPoint: createReleaseCommand
        }
//            name: 'upload-release',
//            desc: 'Uploads a signed .zip to Cordova\'s webserver.',
//            entryPoint: null
    ];
    var commandMap = {};
    for (var i = 0; i < commandList.length; ++i) {
        commandMap[commandList[i].name] = commandList[i];
    }
    var usage = 'Usage: $0 command [options]\n' +
               '\n' +
               'Valid commands:\n';
    for (var i = 0; i < commandList.length; ++i) {
        usage += '    ' + commandList[i].name + ': ' + commandList[i].desc + '\n';
    }
    usage += '\nFor help on a specific command: $0 command --help';

    var command;
    var argv = optimist
        .usage(usage)
        .check(function(argv) {
            command = argv._[0];
            if (!command) {
                throw 'No command specified.';
            }
            if (!commandMap[command]) {
                throw 'Unknown command: ' + command;
            }
        }).argv;

    commandMap[command].entryPoint();
}
main();
